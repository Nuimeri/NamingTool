## プロダクト基本設計：GASとGemini APIによるネーミング生成アプリ

### 1\. プロダクトのゴール

  * ユーザーが入力したキーワードから、**Gemini API** を利用して多様なネーミング案を生成し表示する。
  * **GAS (Google Apps Script)** を用いて、サーバーレスかつ無料で動作するWebアプリケーションを構築する。
  * 開発プロセスを**TDD**と\*\*生成AI（Gemini API、または開発支援AIエージェント）\*\*の活用事例として、チュートリアル記事にまとめる。

### 2\. プロダクトの機能要件

ユーザー目線で必要な機能を定義します。

1.  **キーワード入力:** ユーザーがネーミングの基となるキーワード（例：カフェ、テクノロジー、癒し）を入力できる。
2.  **ネーミング生成リクエスト:** 入力されたキーワードを基に、ネーミング生成を要求するボタンがある。
3.  **ネーミング生成結果表示:** Gemini APIから返却されたネーミング案を一覧で表示する。
4.  **コピー機能 (任意):** 生成されたネーミング案を簡単にコピーできる機能。（MVPでは省略可）

### 3\. システム構成

GASのWebアプリとして、フロントエンドとバックエンドの役割を明確に分けます。

```mermaid
graph TD
    A[ユーザー] -->|Webブラウザ| B[GAS Webアプリ (HTML/CSS/JS)]
    B -->|キーワード入力| C[GASサーバーサイドスクリプト (doGet/doPost)]
    C -->|Gemini API呼び出し| D[Google AI Studio (Gemini API)]
    D -->|ネーミング案返却| C
    C -->|ネーミング案を整形| B
    B -->|結果表示| A
```

### 4\. モジュール分割とTDDへの適用方針

TDDを適用しやすくするため、主要な処理を以下のようにモジュール（GASのスクリプトファイル）に分割し、それぞれの責務を明確にします。これにより、各モジュールを独立してテストしやすくなります。

-----

#### 4.1. フロントエンド（`Code.gs` 内の `doGet()` から提供されるHTML/JS）

  * **ファイル名:** `index.html`, `app.js` (または `Code.gs` 内に直接記述)
  * **責務:**
      * ユーザーインターフェース (UI) の描画（キーワード入力フォーム、生成ボタン、結果表示エリア）。
      * ユーザー入力の取得。
      * **GASサーバーサイドスクリプト** へのリクエスト送信。
      * **GASサーバーサイドスクリプト** からのレスポンス表示。
  * **TDD適用方針:**
      * DOM操作やイベントハンドリングのテストは、GAS環境の制約上、単体テストは難しいですが、基本的なHTML構造やJavaScriptの動作確認はブラウザのデベロッパーツールのコンソールで行います。
      * リクエスト送信前後のデータの整形など、純粋なJavaScriptロジック部分はテスト可能です。（例：キーワードのバリデーション関数など）

-----

#### 4.2. バックエンド（GASサーバーサイドスクリプト）

ここがTDDの主要な適用ポイントとなります。各機能が独立した関数として定義されるため、テストコードを書きやすくなります。

##### 4.2.1. `Code.gs` (エントリポイント)

  * **責務:**
      * Webアプリのエントリポイント (`doGet()`): `index.html` を提供する。
      * POSTリクエストの処理 (`doPost()`): フロントエンドからのネーミング生成リクエストを受け付ける。
      * 主要な処理（`NamingService.gs` や `GeminiApi.gs` の呼び出し）のオーケストレーション。
  * **TDD適用方針:**
      * `doPost()` はHTTPリクエストオブジェクトを受け取るため、テストデータのモック作成が必要です。
      * 内部で呼び出すサービス（`NamingService`など）のテストは、それぞれのモジュールで行うため、`Code.gs` 自体は結合テストの側面が強くなります。

##### 4.2.2. `NamingService.gs` (ネーミング生成ロジック)

  * **責務:**
      * ユーザーから受け取ったキーワードを元に、Gemini APIへのプロンプトを作成する。
      * **GeminiApi.gs** を呼び出し、ネーミング案を取得する。
      * 取得したネーミング案を整形し、フロントエンドに返すためのデータ形式に変換する。
      * （将来的な拡張）ネーミングのタイプ指定（例：クール、可愛い）に応じたプロンプト生成。
      * （将来的な拡張）ネーミング案のフィルタリングや追加処理。
  * **TDD適用方針:**
      * **最重要モジュール:** プロンプト生成ロジックや、Gemini APIからのレスポンスを整形するロジックは、純粋な関数として実装し、入力と出力に基づいて厳密にテストします。
      * `GeminiApi.gs` の呼び出し部分はモック化し、APIのレスポンスパターンをシミュレートしてテストします。
      * 例: `generatePrompt(keyword)` 関数、`parseApiResponse(apiResponse)` 関数など。

##### 4.2.3. `GeminiApi.gs` (Gemini APIとの連携)

  * **責務:**
      * Gemini APIへのHTTPリクエストを構築し、送信する。
      * Gemini APIからのレスポンスを受け取り、エラーハンドリングを行う。
      * APIキーの安全な管理（GASのスクリプトプロパティから取得）。
  * **TDD適用方針:**
      * `UrlFetchApp` などの外部サービス呼び出し部分はモック化し、APIの正常系、異常系レスポンスをシミュレートしてテストします。
      * リクエストの構築（ヘッダー、ボディなど）が正しく行われているかをテストします。
      * 例: `callGeminiApi(promptText)` 関数。

##### 4.2.4. `Utils.gs` (共通ユーティリティ)

  * **責務:**
      * ログ出力関数。
      * 文字列操作、配列操作など、汎用的に利用できるヘルパー関数。
      * （将来的な拡張）バリデーション関数など。
  * **TDD適用方針:**
      * 純粋な関数として定義し、入力と出力に基づいてテストします。独立性が高いため、テストしやすいモジュールです。

-----

#### 4.3. テスト環境

  * **GAS組み込みのテスト機能:** GASには標準でQUnitベースのテストフレームワークが組み込まれています。これを利用して単体テストを記述します。
  * **Mocks/Stubs:** `UrlFetchApp` など外部サービスを呼び出す部分は、テスト時にモックオブジェクトに置き換えることで、APIを実際に呼び出すことなくロジックのテストが可能です。

### 5\. 開発進行におけるTDDと生成AIの活用

チュートリアル記事のテーマに沿って、以下の観点を意識して開発を進めます。

1.  **テストファースト:** 各機能の実装前に、まずテストコードを書く。
2.  **生成AIによるテストコード生成:** 実装する関数の仕様を生成AIに伝え、テストコードのひな形や具体的なテストケースを提案してもらう。
3.  **生成AIによるコード生成/リファクタリング支援:** テストが失敗することを確認した後、生成AIに実装コードの提案や、既存コードのリファクタリング案を尋ねる。
4.  **AIエージェントの利用 (応用):** 複雑な処理や特定の課題解決において、AIエージェントの概念（プロンプトに役割を与え、複数回の対話で目的を達成する）を模倣したプロンプトエンジニアリングを試みる。（例：ネーミング案の評価基準をAIに与え、AI自身に評価・選定させる、など）

### 6\. 今後のステップ

この基本設計を基に、具体的な開発を進めていきましょう。

1.  **GAS環境のセットアップ:** 新しいGASプロジェクトを作成。
2.  **Gemini APIキーの取得:** Google AI StudioでAPIキーを取得。
3.  **最小限の機能の実装とテスト:** まずは `GeminiApi.gs` でAPI呼び出しが正しくできるか、`NamingService.gs` でプロンプトが正しく生成・解析できるかなど、バックエンドの核となる部分からTDDで開発を進めます。
4.  **フロントエンドの作成:** バックエンドの機能が動作することを確認しながら、UIを実装します。
